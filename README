librx
=====

Regular expression features supported
=====================================

abc            character
a|b|c          or
(abc)          capture group
(?:abc)        non-capture group
a*             zero or more
a+             one or more
a?             zero or one
a{3,5}         quantified
a*?            zero or more nongreedy
a+?            one or more nongreedy
a??            zero or one nongreedy
a{3,5}?        quantified nongreedy
^abc           start of string
^^abc          start of line
abc$           end of string
abc$$          end of line
\Gabc          start of position
\<abc\>        word boundaries
\c             ignore case
[abc]          character class
[a-z]          ranges in character class
[α-ω]          unicode character ranges too
.              any character
\n             newline
\r             carriage return
\t             tab
\e             escape
\N             not newline
\d             digit character
\D             not digit character
\w             word character
\W             not word character
\s             space character
\S             not space character
\x2a           hex character
\u2603         4 digit hex unicode codepoint
\U00002603     8 digit hex unicode codepoint

Character oriented square brackets
==================================

The [] operator in this regexp parser are character oriented, so if you a have a
string like "☃" and you apply regexp like this to it:

    [\W]

It would match the entire non-word character of "☃". However if you didnt have
that in a character class and instead used a regexp like:

    \W

It would match the first non-word byte in the string, which for "☃", would match
"\xe2". "☃" is represented in utf8 as "\xe2\x98\x83".

Normally, outside of a character class, it doesn't matter if you match byte by
byte since you will match all 3 of them in a row. For example, a regexp of:

    ☃

would match the string "☃" since those bytes are in order. In a character class,
the regexp of:

    [☃]

would be very wrong since it would think you wanted to match 3 separate bytes no
matter what order they came in.

Testing
=======

The library is tested by running the program written in test.c. It reads testdata.txt
and outputs test results. Read test.c for a description of the format of testdata.txt.

