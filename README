librx
=====

This is a regular expression library. It can take a regular expression and match
a string against it. For example, the regular expression:

    (abc)+\d+

Could be used to match against a string like:

    abcabcabc123

It's mostly like perl regular expressions but I doctored it with some features I
think are useful from other regexp languages like \c (ignorecase), \< (left word
boundary), and \> (right word boundary), ^^ (start of line), and $$ (end of line).

It backtracks using an array instead of recursing.

It handles utf8 nicely without losing the ability to handle strings of arbitrary bytes.

It can reuse memory each time you create or match against a regexp.

It supports greedy/nongreedy quantifiers.

It supports capture groups.

There are no flags (ignore case, multi line, single line, etc.). Instead there are
syntactical features inside of the regexp you can use. For example, instead of /i
flag, use the \c escape sequence.

It uses string size instead of looking for a zero byte to indicate end of string.
This is useful for binary strings that contain inner zero bytes, and for matching
inside larger strings that you might not want the regexp to go further than a
particular spot.

Regular expression features supported
=====================================

abc            character
αβγ            unicode character
a|b|c          or
(abc)          capture group
(?:abc)        non-capture group
a*             zero or more
a+             one or more
a?             zero or one
a{3,5}         quantified
a*?            zero or more nongreedy
a+?            one or more nongreedy
a??            zero or one nongreedy
a{3,5}?        quantified nongreedy
^abc           start of string
^^abc          start of line
abc$           end of string
abc$$          end of line
\Gabc          start of position
\<abc\>        word boundaries
\c             ignore case
[abc]          character class
[a-z]          ranges in character class
[α-ω]          unicode character ranges too
.              any character
\n             newline
\r             carriage return
\t             tab
\e             escape
\N             not newline
\d             digit character
\D             not digit character
\w             word character
\W             not word character
\s             space character
\S             not space character
\x2a           hex character
\u2603         4 digit hex unicode codepoint
\U00002603     8 digit hex unicode codepoint

Character oriented square brackets
==================================

The [] operator in this regexp library is character oriented, so if you a have a
string like "☃" and you apply regexp like this to it:

    [\W]

It would match the entire non-word character of "☃". However if you didnt have
that in a character class and instead used a regexp like:

    \W

It would match the first non-word byte in the string, which for "☃", would match
"\xe2". "☃" is represented in utf8 as "\xe2\x98\x83".

Normally, outside of a character class, it doesn't matter if you match byte by
byte since you will match all 3 of them in a row. For example, a regexp of:

    ☃

would match the string "☃" since those bytes are in order. In a character class,
the regexp of:

    [☃]

would be very wrong since it would think you wanted to match 3 separate bytes no
matter what order they came in.

Testing
=======

The library is tested by running the program written in testsuite.c. It reads
testdata.txt and outputs test results. Read testsuite.c for a description of the
format of testdata.txt.

