librx
=====

Regular expression features supported
=====================================

abc            character
a|b|c          or
(abc)          capture group
(?:abc)        non-capture group
a*             zero or more
a+             one or more
a?             zero or one
a{3,5}         quantified
a*?            zero or more nongreedy
a+?            one or more nongreedy
a??            zero or one nongreedy
a{3,5}?        quantified nongreedy
^abc           start of string
^^abc          start of line
abc$           end of string
abc$$          end of line
\Gabc          start of position
\<abc\>        word boundaries
\c             ignore case
[abc]          character class
[a-z]          ranges in character class
[α-ω]          unicode character ranges too
.              any character
\n             newline
\r             carriage return
\t             tab
\e             escape
\N             not newline
\d             digit character
\D             not digit character
\w             word character
\W             not word character
\s             space character
\S             not space character
\x2a           hex character
\u2603         4 digit hex unicode codepoint
\U00002603     8 digit hex unicode codepoint

Character oriented square brackets
==================================

The [] operator in this regexp parser are character oriented, so if you a have a
string like "☃" and you apply regexp like this to it:

    [\W]

It would match the entire non-word character of "☃". However if you didnt have
that in a character class and instead used a regexp like:

    \W

It would match the first non-word byte in the string, which for "☃", would match
"\xe2". "☃" is represented in utf8 as "\xe2\x98\x83".

Normally, outside of a character class, it doesn't matter if you match byte by
byte since you will match all 3 of them in a row. For example, a regexp of:

    ☃

would match the string "☃" since those bytes are in order. In a character class,
the regexp of:

    [☃]

would be very wrong since it would think you wanted to match 3 separate bytes no
matter what order they came in.

Regexp Test File Format
=======================

Idea for the testing of this library, if I turned it into a full fledged project
on it's own:

In nfa.c there would be a function called rx_parse_test_file(), which can be used to test regular expressions against strings and test the output is as expected. The format of the input file is like this:

# comment
regexp
    string
    expected
    string
    expected
    string
    expected

Comments must appear on a line by themselves.

Strings and expected values need to be on only one line. So if they contain newlines, you have to use \n. The other backslash escapes are available too, includeing \x12, \u1234, \U12341234, \r, \t, and \e. Anything else that is backslashed will convert to itself.

If an expected string is ~ that means it is not a match. If your expected string is actually just a ~, you need to backslash it as \~.

If the expected string starts with a digit colon, like "1: expected", it will match capture 1, instead of capture 0, which is the whole match. If you want to match an empty string for the entire match, use "0: ", empty is different from a non-match ~. If your actual expected string is "1: blahblah", you will need to backslash the beginning 1 like "\1: blahblah".

Regexps must start on the leftmost part of the line. Strings and expected strings must be indented.

